---
date: 2014-07-31
layout: post
comments: yes
code: yes
title: JavaScript学习：RegExp 类型
categories: 笔记
tags: [js,reading_notes]
---

ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式：

    var expression = /pattern/flags;

其中的模式（pattern）部分可以是任意简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找，以及反向引用。每个正则表达式都可带有一个或多个标志（flags），用以表明正则表达式的行为。正则表达式的匹配模式支持下列3个标志：

> g:表示全局（global）模式，即模式将被因用于所有字符串，而非在发现第一个匹配项时立即停止；  
> i:表示区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；  
> m:表示多行（multiline）模式，记载到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同的结果，如下面的例子所示：

    //匹配字符串中所有"at"的实例
    var pattern1 = /at/g;
    //匹配第一个"bat"或"cat"，不区分大小写
    var pattern2 = /[bc]at/i;
    //匹配所有以"at"结尾的3个字符串的组合，不区分大小写
    var pattern3 = /.at/gi;

与其它语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：

    ( [ { \ ^ & | ) ? * + . ]}

这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子：

    //匹配第一个"bat"或"cat"
    var pattern1 = /[bc]at/i;
    //匹配第一个“[bc]at”，不区分大小写
    var pattern2 = /\[bc\]at/i;
    //匹配所有以"at"结尾的3个字符的组合，不区分大小写
    var pattern3 = /.at/i;
    //匹配所有".at"，不区分大小写
    var pattern4 = /\.at/i;

前面举的例子都是以字面量的形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接受两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：

    //匹配第一个“bat”或“cat”,不区分大小写
    var pattern1 = /[bc]at/i;
    //与pattern1相同，只不过是使用构造函数创建的
    var pattern2 = new RegExp("[bc]at", "i");

pattern1和pattern2是两个完全等价的正则表达式。传递给RegExp构造函数的零个参数都是字符串（不能把正则表达式字面量传递个RegExp）构造函数。由于RegExt构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义的字符也是如此，例如\n(字符\在字符串中通常被转义为\\，而在正则表达式字符串中就会被变成\\\\)。下表列出了一些模式，左边是这些模式的字面量形式，右边是使用RegExt构造函数定义相同模式时使用的字符串。

<table>
    <tbody>
        <tr>
            <th>字面量模式</th>
            <th>等价的字符串</th>
        </tr>
        <tr>
            <td>/\[bc\]at/</td>
            <td>“/\\[bc\\]at/”</td>
        </tr>
        <tr>
            <td>/\.at/</td>
            <td>“/\\.at/”</td>
        </tr>
        <tr>
            <td>/name\/age/</td>
            <td>“/name\\/age/”</td>
        </tr>
        <tr>
            <td>/\d.\d{1,2}/</td>
            <td>“/\\d.\\d{1,2}/”</td>
        </tr>
        <tr>
            <td>/\w\\hello\\123/</td>
            <td>“/\\w\\\\hello\\\\123/”</td>
        </tr>
    </tbody>
</table>